import org.specs2._

object EntitySpec extends Specification { def is =
  "this is a specification to check the generated entity source"              ^
                                                                              p^
  "the generated entity source should"                                        ^
    "start with // Generated by"                                              ! entity1^
    "produce package mapped to the target namespace"                          ! entity2^
                                                                              end^
  "xs:string should"                                                          ^
    "be referenced as String"                                                 ! builtin1^
                                                                              end^
  "restrictions of xs:positiveInteger should"                                 ^
    "be referenced as BigInt"                                                 ! restriction1^
                                                                              end^
  "restrictions of simple type should"                                        ^
    "be referenced as its base built-in type"                                 ! restriction2^
                                                                              end^
  "lists of a simple type should"                                             ^
    "be referenced as Seq of its base type"                                   ! derivation1^
                                                                              end^
  "unions of simple types should"                                             ^
    "be referenced as String"                                                 ! union1^
                                                                              end^
  "top-level simple types with enumeration should"                            ^
    "generate a trait named similarly"                                        ! enum1^
    "each enumerations represented as case object"                            ! enum2^
    "be referenced as the trait"                                              ! enum3^
                                                                              end^
  "top-level complex types should"                                            ^
    "generate a case class named similarly"                                   ! complexType1^
    "not generate case class for the primary sequence"                        ! complexType2^
    "be referenced as the class/trait"                                        ! complexType3^
    "be referenced as Option[A] if nillable"                                  ! complexType3^
    "be referenced as Option[A] if optional"                                  ! complexType3^
    "be referenced as Option[Option[A]] if nillable and optional"             ! complexType3^
    "be referenced as Seq[A] if maxOccurs >1"                                 ! complexType3^
    "be referenced as Seq[Option[A]] if nillable and maxOccurs >1"            ! complexType3^
                                                                              end^
  "top-level elements with a local complex type should"                       ^
    "generate a case class named similarly"                                   ! element1^
                                                                              end^
  "local elements with a local complex type should"                           ^
    "generate a case class named similarly"                                   ! localelement1^
                                                                              end^
  "sequences in a complex type should"                                        ^
    "generate a case class named FooSequence* for non-primary sequences"      ! seq1^
    "be referenced as fooSequence within the type"                            ! seq2^
    "not generate anything when the primary sequence is empty"                ! seq3^
    "generate a case class if the primary sequence is either optional or multiple" ! seq4^
    "be split into chunks of case classes when it exceeds 20 particles"       ! seq5^
    "generate accessors for elements within the wrapped sequence"             ! seq6^
                                                                              end^
  "choices in a complex type should"                                          ^
    "generate a trait named FooOption*"                                       ! choice1^
    "be referenced as DataRecord[FooOption] if it's made of non-nillable complex type element" ! choice2^
    "be referenced as DataRecord[Option[FooOption]] if it's made of complex types, some nillable" ! choice2^
    "be referenced as DataRecord[Int] if it's made of xs:int"                 ! choice2^
                                                                              end^
  "an all in a complex type should"                                           ^
    "be referenced as Map[String, scalaxb.DataRecord[Any]]"                   ! all1^
                                                                              end^
  "wildcards should"                                                          ^
    "be referenced as DataRecord[Any] named any*"                             ! wildcard1^
    "be referenced as Option[DataRecord[A]] if optional"                      ! wildcard2^
    "be referenced as Seq[DataRecord[A]] if maxOccurs >1"                     ! wildcard2^
                                                                              end^
  "a single particle with maxOccurs >1 should"                                ^
    "be referenced as A*"                                                     ! param1^
                                                                              end^
  "substitution groups should"                                                ^
    "be referenced as the group head's type"                                  ! sub1^
                                                                              end^
  "attriubtes should"                                                         ^
    "be referenced as Map[String, scalaxb.DataRecord[Any]]"                   ! attr1^
    "generate an accessor"                                                    ! attr2^
                                                                              end^
  "attribute groups should"                                                   ^
    "generate a trait with attribute accessor signatures"                     ! attributegroup1^
    "generate accessors in the referencing complex type"                      ! attributegroup2^
    "be extended by the referencing complex types"                            ! attributegroup3^
                                                                              end

  import Example._
  lazy val module = new scalaxb.compiler.xsd2.Driver
  lazy val emptyEntitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" />, "example1")(0)

  def entity1 = {
    println(emptyEntitySource)
    emptyEntitySource must startWith("// Generated by")
  }

  def entity2 = {
    emptyEntitySource must find("""package example1""".stripMargin)
  }

  val builtInEntitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/"
      xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:complexType name="Address">
      <xs:sequence>
        <xs:element name="street" type="xs:string"/>
        <xs:element name="city" type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:schema>, "example")(0)

  def builtin1 = {
    println(builtInEntitySource)
    builtInEntitySource must find(
      """case class Address\(street: String,\s*
        |\s*city: String\)""".stripMargin)
  }

  def restriction1 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/"
        xmlns:xs="http://www.w3.org/2001/XMLSchema">
      <xs:complexType name="SimpleTypeTest">
        <xs:sequence>
          <xs:element name="quantity">
            <xs:simpleType>
              <xs:restriction base="xs:positiveInteger">
                <xs:maxExclusive value="100"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

    println(entitySource)
    entitySource must contain("""quantity: BigInt""")
  }

  def restriction2 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:simpleType name="ShortString">
        <xs:restriction base="xs:string">
          <xs:maxLength value="140"/>
        </xs:restriction>
      </xs:simpleType>
      <xs:complexType name="SimpleTypeTest">
        <xs:sequence>
          <xs:element name="comment">
            <xs:simpleType>
              <xs:restriction base="gen:ShortString">
                <xs:maxLength value="100"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:element>
          <xs:element name="comment2">
            <xs:simpleType>
              <xs:restriction>
                <xs:simpleType>
                  <xs:restriction base="gen:ShortString">
                    <xs:maxLength value="130"/>
                  </xs:restriction>
                </xs:simpleType>
                <xs:maxLength value="100"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

    println(entitySource)
    entitySource must contain("""comment: String""") and contain("""comment2: String""")
  }

  def derivation1 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:tns="http://www.example.com">
      <xs:complexType name="SimpleTypeTest">
        <xs:sequence>
          <xs:element name="milklist1" type="tns:ListOfMilk"/>
        </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="ListOfMilk">
        <xs:list itemType="tns:MilkType"/>
      </xs:simpleType>

      <xs:simpleType name="MilkType">
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="WHOLE"/>
          <xs:enumeration value="SKIM"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:schema>, "example")(0)

    println(entitySource)
    entitySource must contain("""milklist1: Seq[example.MilkType]""")
  }

  def union1 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:complexType name="SimpleTypeTest">
        <xs:sequence>
          <xs:element name="union">
            <xs:simpleType>
              <xs:union memberTypes="xs:string xs:int" />
            </xs:simpleType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

    println(entitySource)
    entitySource must contain("""union: String""")
  }

  lazy val enumEntitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/"
      xmlns:tns="http://www.example.com/"
      xmlns:xs="http://www.w3.org/2001/XMLSchema">
    <xs:simpleType name="MilkType">
      <xs:restriction base="xs:NMTOKEN">
        <xs:enumeration value="WHOLE"/>
        <xs:enumeration value="SKIM"/>
      </xs:restriction>
    </xs:simpleType>
    <xs:complexType name="SimpleTypeTest">
      <xs:sequence>
        <xs:element name="milk1" type="tns:MilkType"/>
      </xs:sequence>
    </xs:complexType>
  </xs:schema>, "example")(0)

  def enum1 = {
    println(enumEntitySource)
    enumEntitySource must contain("""trait MilkType""")
  }

  def enum2 = {
    enumEntitySource must contain("""case object SKIM""")
  }

  def enum3 = {
    enumEntitySource must contain("""milk1: MilkType""")
  }

  lazy val complexTypeEntitySource = module.processNode(complexTypeCardinalityXML, "example")(0)

  lazy val expectedComplexTypeTest =
    """case class SingularComplexTypeTest\(person1: Person,\s*
      |\s*person2: Option\[example.Person\],\s*
      |\s*person3: Option\[example.Person\],\s*
      |\s*person4: Option\[Option\[example.Person\]\],\s*
      |\s*person5: Seq\[example.Person\],\s*
      |\s*person6: Seq\[Option\[example.Person\]\]\)""".stripMargin

  def complexType1 = {
    println(complexTypeEntitySource)
    complexTypeEntitySource must contain("""case class Address(""")
  }

  def complexType2 = {
    complexTypeEntitySource must not contain("""AddressSequence""")
  }

  def complexType3 = {
    complexTypeEntitySource must find(expectedComplexTypeTest)
  }

  def element1 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/"
        xmlns:xs="http://www.w3.org/2001/XMLSchema">
      <xs:element name="topLevelElementTest">
        <xs:complexType>
          <xs:sequence>
            <xs:choice maxOccurs="unbounded">
              <xs:element name="foo" type="xs:string"/>
              <xs:any namespace="##other" processContents="lax" />
            </xs:choice>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:schema>, "example")(0)

    println(entitySource)
    entitySource must contain("""case class TopLevelElementTest(""")
  }

  def localelement1 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/ipo"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:ipo="http://www.example.com/ipo">
      <xs:element name="comment" type="xs:string"/>

      <xs:complexType name="Items">
        <xs:sequence>
          <xs:element name="item" minOccurs="0" maxOccurs="unbounded">
            <xs:complexType>
              <xs:sequence>
                <xs:element name="productName" type="xs:string"/>
                <xs:element name="quantity">
                  <xs:simpleType>
                    <xs:restriction base="xs:positiveInteger">
                      <xs:maxExclusive value="100"/>
                    </xs:restriction>
                  </xs:simpleType>
                </xs:element>
                <xs:element name="USPrice"    type="xs:decimal"/>
                <xs:element ref="ipo:comment" minOccurs="0"/>
                <xs:element name="shipDate"   type="xs:date" minOccurs="0"/>
              </xs:sequence>
              <xs:attribute name="partNum" type="xs:int" use="required"/>
            </xs:complexType>
          </xs:element>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

    println(entitySource)
    entitySource must contain("""case class Item(""")
  }

  lazy val seqEntitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:complexType name="SequenceComplexTypeTest">
        <xs:sequence>
          <xs:sequence>
            <xs:element name="person1" type="gen:Person"/>
            <xs:element name="address1" type="gen:Address"/>
          </xs:sequence>
          <xs:sequence>
            <xs:element name="person2" nillable="true" type="gen:Person"/>
            <xs:element name="address2" nillable="true" type="gen:Address"/>
          </xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="person3" type="gen:Person"/>
            <xs:element name="address3" type="gen:Address"/>
          </xs:sequence>
          <xs:sequence minOccurs="0">
            <xs:element name="person4" nillable="true" type="gen:Person"/>
            <xs:element name="address4" nillable="true" type="gen:Address"/>
          </xs:sequence>
          <xs:sequence maxOccurs="unbounded">
            <xs:element name="person5" type="gen:Person"/>
            <xs:element name="address5" type="gen:Address"/>
          </xs:sequence>
          <xs:sequence maxOccurs="unbounded">
            <xs:element name="person6" nillable="true" type="gen:Person"/>
            <xs:element name="address6" nillable="true" type="gen:Address"/>
          </xs:sequence>
          <xs:sequence>
            <xs:element name="int1" type="xs:int"/>
            <xs:element name="int2" type="xs:int"/>
          </xs:sequence>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="EmptySequenceComplexTypeTest">
        <xs:sequence/>
      </xs:complexType>

      <xs:complexType name="LongSequenceComplexTypeTest">
        <xs:sequence>
          <xs:element name="int1" type="xs:int"/>
          <xs:element name="int2" type="xs:int"/>
          <xs:element name="int3" type="xs:int"/>
          <xs:element name="int4" type="xs:int"/>
          <xs:element name="int5" type="xs:int"/>
          <xs:element name="int6" type="xs:int"/>
          <xs:element name="int7" type="xs:int"/>
          <xs:element name="int8" type="xs:int"/>
          <xs:element name="int9" type="xs:int"/>
          <xs:element name="int10" type="xs:int"/>
          <xs:element name="int11" type="xs:int"/>
          <xs:element name="int12" type="xs:int"/>
          <xs:element name="int13" type="xs:int"/>
          <xs:element name="int14" type="xs:int"/>
          <xs:element name="int15" type="xs:int"/>
          <xs:element name="int16" type="xs:int"/>
          <xs:element name="int17" type="xs:int"/>
          <xs:element name="int18" type="xs:int"/>
          <xs:element name="int19" type="xs:int"/>
          <xs:element name="int20" type="xs:int"/>
          <xs:element name="int21" type="xs:int"/>
          <xs:element name="int22" type="xs:int"/>
          <xs:element name="int23" type="xs:int"/>
          <xs:element name="int24" type="xs:int"/>
          <xs:element name="int25" type="xs:int"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="MultipleSequenceComplexTypeTest">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
          <xs:element name="int1" type="xs:int"/>
          <xs:element name="int2" type="xs:int"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="Person">
        <xs:sequence>
          <xs:element name="firstName" type="xs:string"/>
          <xs:element name="lastName" type="xs:string"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="Address">
        <xs:sequence>
          <xs:element name="street" type="xs:string"/>
          <xs:element name="city" type="xs:string"/>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

  val seqExpectedSequenceTest =
    """case class SequenceComplexTypeTest\(sequencecomplextypetestsequence: SequenceComplexTypeTestSequence,\s*
      |\s*sequencecomplextypetestsequence2: SequenceComplexTypeTestSequence2,\s*
      |\s*sequencecomplextypetestsequence3: Option\[example\.SequenceComplexTypeTestSequence3\],\s*
      |\s*sequencecomplextypetestsequence4: Option\[example\.SequenceComplexTypeTestSequence4\],\s*
      |\s*sequencecomplextypetestsequence5: Seq\[example\.SequenceComplexTypeTestSequence5\],\s*
      |\s*sequencecomplextypetestsequence6: Seq\[example\.SequenceComplexTypeTestSequence6\],\s*
      |\s*sequencecomplextypetestsequence7: SequenceComplexTypeTestSequence7\)\s*
      |""".stripMargin

  def seq1 = {
    println(seqEntitySource)
    seqEntitySource must contain("""case class SequenceComplexTypeTestSequence""")
  }

  def seq2 = {
    seqEntitySource must find(seqExpectedSequenceTest)
  }

  def seq3 = {
    seqEntitySource must contain("""case class EmptySequenceComplexTypeTest()""")
  }

  def seq4 = {
    seqEntitySource must contain("""case class MultipleSequenceComplexTypeTest(""" +
      """multiplesequencecomplextypetestsequence: MultipleSequenceComplexTypeTestSequence*)""")
  }

  def seq5 = {
    seqEntitySource must contain("""case class LongSequenceComplexTypeTestSequence(int1: Int""")
  }

  def seq6 = {
    seqEntitySource must contain("""case class LongSequenceComplexTypeTestSequence(int1: Int""")
  }

  lazy val choiceEntitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:complexType name="ChoiceComplexTypeTest">
        <xs:sequence>
          <xs:choice>
            <xs:element name="person1" type="gen:Person"/>
            <xs:element name="address1" type="gen:Address"/>
          </xs:choice>
          <xs:choice>
            <xs:element name="person2" nillable="true" type="gen:Person"/>
            <xs:element name="address2" nillable="true" type="gen:Address"/>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="person3" type="gen:Person"/>
            <xs:element name="address3" type="gen:Address"/>
          </xs:choice>
          <xs:choice minOccurs="0">
            <xs:element name="person4" nillable="true" type="gen:Person"/>
            <xs:element name="address4" nillable="true" type="gen:Address"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded">
            <xs:element name="person5" type="gen:Person"/>
            <xs:element name="address5" type="gen:Address"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded">
            <xs:element name="person6" nillable="true" type="gen:Person"/>
            <xs:element name="address6" nillable="true" type="gen:Address"/>
          </xs:choice>
          <xs:choice>
            <xs:element name="int1" type="xs:int"/>
            <xs:element name="int2" type="xs:int"/>
          </xs:choice>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="Person">
        <xs:sequence>
          <xs:element name="firstName" type="xs:string"/>
          <xs:element name="lastName" type="xs:string"/>
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="Address">
        <xs:sequence>
          <xs:element name="street" type="xs:string"/>
          <xs:element name="city" type="xs:string"/>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

  val expectedChoiceTest =
    """case class ChoiceComplexTypeTest\(choicecomplextypetestoption: scalaxb.DataRecord\[example\.ChoiceComplexTypeTestOption\],\s*
      |\s*choicecomplextypetestoption2: scalaxb.DataRecord\[Option\[example\.ChoiceComplexTypeTestOption2\]\],\s*
      |\s*choicecomplextypetestoption3: Option\[scalaxb.DataRecord\[example\.ChoiceComplexTypeTestOption3\]\],\s*
      |\s*choicecomplextypetestoption4: Option\[scalaxb.DataRecord\[Option\[example\.ChoiceComplexTypeTestOption4\]\]\],\s*
      |\s*choicecomplextypetestoption5: Seq\[scalaxb.DataRecord\[example\.ChoiceComplexTypeTestOption5\]\],\s*
      |\s*choicecomplextypetestoption6: Seq\[scalaxb.DataRecord\[Option\[example\.ChoiceComplexTypeTestOption6\]\]\],\s*
      |\s*choicecomplextypetestoption7: scalaxb.DataRecord\[Int\]\)\s*
      |""".stripMargin

  def choice1 = {
    println(choiceEntitySource)
    choiceEntitySource must contain("""trait ChoiceComplexTypeTestOption""")
  }

  def choice2 = {
    choiceEntitySource must find(expectedChoiceTest)
  }

  def all1 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:complexType name="AllComplexTypeTest">
        <xs:all>
          <xs:element name="address1" type="gen:Address"/>
          <xs:element name="address2" minOccurs="0" type="gen:Address"/>
          <xs:element name="string3" type="xs:string"/>
          <xs:element name="string4" type="xs:string"/>
          <xs:element name="string5" type="xs:string"/>
          <xs:element name="string6" type="xs:string"/>
        </xs:all>
      </xs:complexType>

      <xs:complexType name="Address">
        <xs:sequence>
          <xs:element name="street" type="xs:string"/>
          <xs:element name="city" type="xs:string"/>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

    println(entitySource)
    entitySource must contain("""case class AllComplexTypeTest(all: Map[String, scalaxb.DataRecord[Any]])""")
  }

  lazy val wildcardEntitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:gen="http://www.example.com/general">
    <xs:complexType name="AnyTest2">
      <xs:sequence>
        <xs:any minOccurs="0" />
        <xs:element name="foo" type="xs:string" />
        <xs:any/>
        <xs:element name="foo2" type="xs:string" />
        <xs:any maxOccurs="unbounded" />
      </xs:sequence>
    </xs:complexType>
  </xs:schema>, "example")(0)

  val exptectedAnyTest =
    """case class AnyTest2\(any: Option\[scalaxb\.DataRecord\[Any\]\],\s*
      |\s*foo: String,\s*
      |\s*any2: scalaxb\.DataRecord\[Any\],\s*
      |\s*foo2: String,\s*
      |\s*any3: Seq\[scalaxb\.DataRecord\[Any\]\]\)""".stripMargin

  def wildcard1 = {
    println(wildcardEntitySource)
    wildcardEntitySource must find(exptectedAnyTest)
  }

  def wildcard2 = {
    wildcardEntitySource must find(exptectedAnyTest)
  }

  def param1 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:complexType name="SeqParamTest">
        <xs:sequence>
          <xs:element name="foo" type="xs:string" maxOccurs="unbounded" />
        </xs:sequence>
      </xs:complexType>

      <xs:complexType name="NillableSeqParamTest">
        <xs:sequence>
          <xs:element name="foo" type="xs:string" maxOccurs="unbounded" nillable="true" />
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

    val exptectedSeqParamTest =
      """case class SeqParamTest\(foo: String\*\)\s*
        |\s*case class NillableSeqParamTest\(foo: Option\[String\]\*\)""".stripMargin

    println(entitySource)
    entitySource must find(exptectedSeqParamTest)
  }

  def sub1 = {
    val entitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:simpleType name="MilkType">
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="WHOLE"/>
          <xs:enumeration value="SKIM"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:element name="SubstitutionGroup" type="xs:anyType" abstract="true"/>
      <xs:element name="SubGroupMember" type="gen:MilkType" substitutionGroup="gen:SubstitutionGroup"/>
      <xs:element name="SubGroupMember2" type="xs:int" substitutionGroup="gen:SubstitutionGroup"/>

      <xs:complexType name="SubstitutionGroupTest">
        <xs:sequence>
          <xs:element ref="gen:SubstitutionGroup"/>
        </xs:sequence>
      </xs:complexType>
    </xs:schema>, "example")(0)

    println(entitySource)
    entitySource must contain("""case class SubstitutionGroupTest(SubstitutionGroup: scalaxb.DataRecord[Any])""")
  }

  lazy val attrEntitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:simpleType name="MilkType">
        <xs:restriction base="xs:NMTOKEN">
          <xs:enumeration value="WHOLE"/>
          <xs:enumeration value="SKIM"/>
        </xs:restriction>
      </xs:simpleType>

      <xs:element name="attributeTest">
        <xs:complexType>
          <xs:attribute name="milk1" type="gen:MilkType"/>
          <xs:attribute name="string2" type="xs:string"/>
          <xs:anyAttribute namespace="##any"/>
        </xs:complexType>
      </xs:element>

      <xs:complexType name="anySimpleTypeExtension">
        <xs:simpleContent>
          <xs:extension base="xs:anySimpleType">
             <xs:anyAttribute namespace="##any" processContents="lax"/>
          </xs:extension>
        </xs:simpleContent>
      </xs:complexType>
    </xs:schema>, "example")(0)

  def attr1 = {
    println(attrEntitySource)
    attrEntitySource must contain("""case class AttributeTest(attributes: Map[String, scalaxb.DataRecord[Any]])""")
  }

  def attr2 = {
    attrEntitySource must contain("""lazy val milk1: Option[example.MilkType] = attributes.get("@milk1") map {_.as[MilkType]}""")
  }

  lazy val attributeGroupEntitySource = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
        xmlns:xs="http://www.w3.org/2001/XMLSchema"
        xmlns:gen="http://www.example.com/general">
      <xs:attributeGroup name="coreattrs">
        <xs:attribute name="id" type="xs:ID"/>
        <xs:attribute name="class" type="xs:NMTOKENS"/>
      </xs:attributeGroup>

      <xs:element name="attributeGroupTest">
        <xs:complexType>
          <xs:attributeGroup ref="gen:coreattrs"/>
        </xs:complexType>
      </xs:element>
    </xs:schema>, "example")(0)

  def attributegroup1 = {
    println(attributeGroupEntitySource)
    attributeGroupEntitySource must find("""trait Coreattrs \{\s*
                             |\s*def id\: Option\[String\]""".stripMargin)
  }

  def attributegroup2 = {
    attributeGroupEntitySource must contain("""lazy val id: Option[String] = attributes.get("@id") map {_.as[String]}""")
  }

  def attributegroup3 = {
    attributeGroupEntitySource must contain("""case class AttributeGroupTest(attributes: Map[String, scalaxb.DataRecord[Any]]) extends Coreattrs""")
  }
}

package scalaxb.specs

import org.specs2._

object ProtocolSpec extends Specification { def is = sequential               ^
  "this is a specification to check the generated protocol source"            ^
                                                                              p^
  "the generated protocol source should"                                      ^
    "start with // Generated by"                                              ! protocol1^
                                                                              end^
  "top-level complex types should"                                            ^
    "generate a format typeclass instance"                                    ! complexType1^
    "generate a combinator parser"                                            ! parser1^
    "generate an XML writer"                                                  ! output1^
    "be referenced as Option[A] in the parser if nillable"                    ! cardinality1^
                                                                              end^
  "complex derivation of simple type should"                                  ^
    "generate a simple protocol"                                              ! derivation1^
                                                                              end^
  "complex derivation of complex type should"                                 ^
    "generate a simple protocol"                                              ! derivation2^
                                                                              end^
  "top-level simple type with enumeration should"                             ^
    "generate a combinator parser"                                            ! enum1^ 
                                                                              end^
  "top-level named groups should"                                             ^
    "generate a combinator parser"                                            ! namedGroup1^ 
                                                                              end^
  "sequences in complex type should"                                          ^
    "generate a combinator parser"                                            ! seq1^ 
                                                                              end^
  "choices in a complex type should"                                          ^
    "generate a combinator parser"                                            ! choice1^ 
                                                                              end^
  "an all in a complex type should"                                           ^
    "generate a combinator parser"                                            ! all1^ 
                                                                              end^
  "a groupref in a complex type should"                                       ^
    "generate a reference to group parsing method"                            ! groupref1^
                                                                              end^
  "wildcards in a complex type should"                                        ^
    "generate a combinator parser"                                            ! wildcard1^
                                                                              end^
  "a single particle with maxOccurs >1 should"                                ^
    "generate a combinator parser that uses _*"                               ! arg1^    
                                                                              end^
  "attributes in complex type should"                                         ^
    "generate a combinator parser"                                            ! attribute1^
                                                                              end

  import Example._
  lazy val module = new scalaxb.compiler.xsd2.Driver
  lazy val emptyProtocol = module.processNode(<xs:schema targetNamespace="http://www.example.com/"
    xmlns:xs="http://www.w3.org/2001/XMLSchema" />, "example")(1)

  def protocol1 = {
    println(emptyProtocol)
    emptyProtocol must startWith("// Generated by")
  }

  lazy val addressProtocol = module.processNode(<xs:schema targetNamespace="http://www.example.com/general"
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:gen="http://www.example.com/general"
      elementFormDefault="qualified">
    <xs:complexType name="Address">
      <xs:sequence>
        <xs:element name="street" type="xs:string"/>
        <xs:element name="city" type="xs:string"/>
      </xs:sequence>
    </xs:complexType>
  </xs:schema>, "example1")(1)

  def complexType1 = {
    println(addressProtocol)
    addressProtocol.lines.toList must contain (
      """implicit lazy val Example1AddressFormat: scalaxb.XMLFormat[example1.Address] = new DefaultExample1AddressFormat {""",
      """trait DefaultExample1AddressFormat extends scalaxb.ElemNameParser[example1.Address] {"""
    )
  }

  def parser1 = {
    (addressProtocol must contain(
      """(scalaxb.ElemName(Some("http://www.example.com/general"), "street")) ~""")) and
    (addressProtocol must contain(
      """(scalaxb.ElemName(Some("http://www.example.com/general"), "city"))""")) and
    (addressProtocol must contain(
      """case p1 ~ p2 =>""")) and
    (addressProtocol must contain(
      """example1.Address(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),"""))
  }

  def output1 = {
    (addressProtocol must contain(
      """def writesChildNodes(__obj: example1.Address, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =""")) and
    (addressProtocol must contain(
      """Seq.concat(scalaxb.toXML[String](__obj.street, Some("http://www.example.com/general"), Some("street"), __scope, false),"""))
  }

  lazy val cardinalityProtocol = module.processNode(complexTypeCardinalityXML, "example")(1)

  def cardinality1 = {
    println(cardinalityProtocol)
    (cardinalityProtocol must contain(
      """scalaxb.toXML[Option[example.Person]](__obj.person2, None, Some("person2"), __scope, false)"""))
  }

  lazy val derivProcolSource = module.processNode(derivationXML, "example")(1)

  def derivation1 = {
    println(derivProcolSource)
    (derivProcolSource must contain(
      """example.ComplexListOfMilk(scalaxb.fromXML[Seq[example.MilkType]](node, scalaxb.ElemName(node) :: stack),"""))
  }

  lazy val addressProcolSource = module.processNode(addressXML, "example")(1)

  def derivation2 = {
    println(addressProcolSource)
    (addressProcolSource must contain(
      """trait DefaultExampleAddressableFormat extends scalaxb.XMLFormat[example.Addressable] {""")) and
   (addressProcolSource must contain(
      """case (Some("http://www.example.com/general"), Some("USAddress")) => Right(scalaxb.fromXML[example.USAddress](node, stack))""")) 
  }

  def enum1 = {
    (derivProcolSource must contain(
      """trait DefaultExampleMilkTypeFormat extends scalaxb.XMLFormat[example.MilkType] {""")) 
  }

  lazy val namedGroupProtocol = module.processNode(namedGroupXML, "example")(1)
  
  def namedGroup1 = {
    println(namedGroupProtocol)
    (namedGroupProtocol must contain(
      """  def parseSeqGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[example.SeqGroup] = (((scalaxb.ElemName(None, "city"))) ^^ {"""))    
  }

  lazy val seqProtocol = module.processNode(sequenceXML, "example")(1)

  def seq1 = {
    println(seqProtocol)
    (seqProtocol must contain (
      """((scalaxb.ElemName(None, "person1")) ~ (scalaxb.ElemName(None, "address1"))) ^^ {
    case p1 ~ p2 => example.SequenceComplexTypeTestSequence(scalaxb.fromXML[example.Person](p1, scalaxb.ElemName(node) :: stack), scalaxb.fromXML[example.Address](p2, scalaxb.ElemName(node) :: stack))
  }"""))
  }

  lazy val choiceProtocol = module.processNode(choiceXML, "example")(1)

  def choice1 = {
    println(choiceProtocol)
    (choiceProtocol must contain (
      """(((scalaxb.ElemName(None, "person1")) ^^ ({ x =>
    scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[example.Person](x, scalaxb.ElemName(node) :: stack))
  })) | ((scalaxb.ElemName(None, "address1")) ^^ ({ x =>
    scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[example.Address](x, scalaxb.ElemName(node) :: stack))
  })))"""))
  }

  def all1 = {
    val p = module.processNode(allXML, "example")(1)
    println(p)
    (p must contain("""example.AllComplexTypeTest(scala.collection.immutable.ListMap((List(""")) and
    (p must contain(""").flatten[(String, scalaxb.DataRecord[Any])]: _*))))"""))
  }

  def groupref1 = {
    val p = module.processNode(grouprefXML, "example")(1)

    println(p)
    (p must contain("""trait DefaultExampleArrayTypeFormat extends scalaxb.ElemNameParser[example.ArrayType] with example.ExampleArrayGroupFormat {""")) and
    (p must contain("""def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[example.ArrayType] = opt(parseArrayGroup(node, scalaxb.ElemName(node) :: stack)) ^^ {"""))
  }

  def wildcard1 = {
    val wilcardProcotol = module.processNode(wildcardXML, "example")(1)
    println(wilcardProcotol)
    wilcardProcotol must contain("""(any(_.namespace != Some("http://www.example.com/general"))) ~""")
  }

  def arg1 = {
    val p = module.processNode(seqParamXML, "example")(1)
    println(p)
    (p must contain("""example.SeqParamTest((p1.toSeq map { x =>""")) and
    (p must contain("""  scalaxb.fromXML[String](x, scalaxb.ElemName(node) :: stack)""")) and
    (p must contain("""}: _*)"""))
  }

  def attribute1 = {
    val p = module.processNode(attributeXML, "example")(1)
    println(p)

    p must contain("""example.AttributeTest(scalaxb.Helper.attributesToMap(node))""")
  }
}
